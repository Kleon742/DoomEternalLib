struct idDemonPlayer_Mancubus : idDemonPlayer
{
    enum eMancubusFireMode : int
    {
        FIREMODE_NORMAL = 0,
        FIREMODE_MORTAR = 1
    };

    struct mancubusData_t
    {
        enum fireDuringDoubleJumpMode_t : int
        {
            FIRE_DURING_DOUBLE_JUMP_DISABLED = 0,
            FIRE_DURING_DOUBLE_JUMP_ALLOWED = 1,
            FIRE_DURING_DOUBLE_JUMP_ALLOWED_WITH_ANIM_EVENT = 2
        };

        // Number of paired shots to fire in a burst
        int fireBurstCount; // Offset: 0x0

        // Whether the Mancubus must be on the ground (not falling/jumping) to fire its weapons
        bool fireRequiresGroundContact; // Offset: 0x4

        // Whether the Mancubus can fire in the air after being launched from a bounce pad
        bool fireAllowedFromBounce; // Offset: 0x5

        // When this is set, heat is not generated by firing and is only used for venting cooldown
        bool noHeat; // Offset: 0x6

        // Whether venting can be stopped by releasing the trigger before all heat is drained
        bool heatVentCanStop; // Offset: 0x7

        // Amount of heat that Mancubus should spawn with
        float heatInitial; // Offset: 0x8

        // Amount of heat generated with each Mancubus rocket volley
        float heatPerShot; // Offset: 0xC

        // Maximum amount of heat the Mancubus can sustain without overheating
        float heatMax; // Offset: 0x10

        // Amount of heat dissipated from the Mancubus rockets when venting per second
        float heatVentDrainPerSec; // Offset: 0x14

        // Amount of heat dissipated from the Mancubus rockets without venting
        float heatDrainPerSec; // Offset: 0x18

        // Minimal amount of heat accumulated before venting is allowed
        float heatVentMin; // Offset: 0x1C

        // Minimal amount of heat remaining before venting is allowed while overheating
        float heatVentMinOverheated; // Offset: 0x20

        // How far back to slide the camera while venting (0 to remain in first person) {{ units = m }}
        float ventCameraDistance; // Offset: 0x24

        // Acceleration while running normally
        float normalAccelerationRate; // Offset: 0x28

        // How much to scale the mancubus' max speed when flamethrowers are raised
        float flameSpeedScale_idle; // Offset: 0x2C

        // How much to scale the mancubus' max speed when firing flamethrowers
        float flameSpeedScale_firing; // Offset: 0x30

        // Delay (in milliseconds) between paired shots in a burst
        idBranchedOptionValue < declInputBranch_t , idTypesafeTime < int , millisecondUnique_t , 1000 > > fireBurstDelay; // Offset: 0x38

        // How long in MS before the mancubus can vent after a vent
        idTypesafeTime < int , millisecondUnique_t , 1000 > ventToVentDelayMS; // Offset: 0x60

        // How long in MS before the mancubus can fire after a vent
        idTypesafeTime < int , millisecondUnique_t , 1000 > ventToFireDelayMS; // Offset: 0x64

        // How long in MS before the mancubus can vent after a fire
        idTypesafeTime < int , millisecondUnique_t , 1000 > fireToVentDelayMS; // Offset: 0x68

        // How long in MS do we hold the invalidInput UI on screen
        idTypesafeTime < int , millisecondUnique_t , 1000 > ventInvalidInputTime; // Offset: 0x6C

        // How long in ms to slide the camera out for third person transitions
        idTypesafeTime < int , millisecondUnique_t , 1000 > ventCameraSlideTime; // Offset: 0x70

        // how long after depleting heat before it can regenerate (in MS)
        idTypesafeTime < int , millisecondUnique_t , 1000 > heatDepletionCooldownMS; // Offset: 0x74

        // fire during double jump mode
        idDemonPlayer_Mancubus::mancubusData_t::fireDuringDoubleJumpMode_t fireDuringDoubleJumpMode; // Offset: 0x78

    }; // Size: 0x80

    struct mortarData_t
    {
        // launch mortar rounds immediately
        bool immediateLaunch; // Offset: 0x0

        // how long to wait before firing first volley of mortars
        idTypesafeTime < int , millisecondUnique_t , 1000 > spinupTime; // Offset: 0x4

        // how many MS after transitioning out from mortar mode can they re-enter mortar mode
        idBranchedOptionValue < declInputBranch_t , idTypesafeTime < int , millisecondUnique_t , 1000 > > cooldown; // Offset: 0x8

        // how many mortars per trigger pull
        int burstCount; // Offset: 0x30

        // how long between shots per burst
        idBranchedOptionValue < declInputBranch_t , idTypesafeTime < int , millisecondUnique_t , 1000 > > burstDelay; // Offset: 0x38

        // how much heat per mortar shot
        float heatPerShot; // Offset: 0x60

        // look sensitivity while in mortar mode
        float lookSensitivity; // Offset: 0x64

        // how much to scale movement speed when in mortar mode
        float moveSpeedScale; // Offset: 0x68

        // sound upon entering mortar mode
        idSoundEvent* enterSound; // Offset: 0x70

        // sound upon exiting mortar mode
        idSoundEvent* exitSound; // Offset: 0x78

        // sound to play when cooldown is complete
        idSoundEvent* readySound; // Offset: 0x80

        // demon card data for the mortar ability
        idDeclDemonCard* demonCard; // Offset: 0x88

        // for internal use only is mortar currently cooling down
        bool coolingDown; // Offset: 0x90

    }; // Size: 0x98

    struct flamethrowerData_t
    {
        // decrement - heat decrements with time, once empty will disable flamethrower How long do they have to hold down alt-fire before they can fire the flamethrower
        idTypesafeTime < int , millisecondUnique_t , 1000 > bringupTime; // Offset: 0x0

        // if true will fire weapon's secondary along w/ flamethrower
        bool spawnProjectile; // Offset: 0x4

        // Entity def to use for launched flame projectiles
        idDeclEntityDef* flameProjectileDef; // Offset: 0x8

        // entityDef for projectile Entity
        idDeclEntityDef* flameProjectileDef2; // Offset: 0x10

        // How much heat to add/remove per second when firing the flamethrower
        float heatPerSecond; // Offset: 0x18

        // time between launched flamethrower projectiles
        idTypesafeTime < int , millisecondUnique_t , 1000 > fireDelay; // Offset: 0x1C

        // event to play when flamethrower bring up starts
        idSoundEvent* startBringup; // Offset: 0x20

        // event to play when flamethrower is ready to fire
        idSoundEvent* flamesReady; // Offset: 0x28

        // event to play when flamethrower starts
        idSoundEvent* fireSound; // Offset: 0x30

        // event to play when flamethrower stops
        idSoundEvent* stopFireSound; // Offset: 0x38

        // failure to fire based on heat state
        idSoundEvent* dryFire; // Offset: 0x40

        // damage decl for the flamethrower
        idDeclDamage* flamethrowerDamageDecl; // Offset: 0x48

        // look sensitivity while flamethrower is being fired
        float sensitivityWhileFiring; // Offset: 0x50

        // flamethrower feedback
        weaponFeedBack_t flamethrowerFeedback; // Offset: 0x58

        // flamethrower view shake
        idDeclAdvancedViewShake* flamethrowerViewShake; // Offset: 0x270

        // false = feedback when flames start, true = feedback on every flame projectile
        bool flamethrowerFeedbackRepeat; // Offset: 0x278

        // false = screen shake when flames start, true = screen shake on every flame projectile
        bool flamethrowerShakeRepeat; // Offset: 0x279

        // if true, must release fire button after depleting heat before can fire again
        bool mustReleaseAfterFire; // Offset: 0x27A

        // time that must elapse between ending flamethrower and starting again
        idTypesafeTime < int , millisecondUnique_t , 1000 > cooldown; // Offset: 0x27C

        // minimum time that flamethrower must fire
        idTypesafeTime < int , millisecondUnique_t , 1000 > minTimeToFire; // Offset: 0x280

        // minimum heat needed to continue firing
        float minHeatToFire; // Offset: 0x284

    }; // Size: 0x288

    struct MancubusInput
    {
        // Main fire
        usercmdButton_t primaryAttack; // Offset: 0x0

        // Swaps firemode
        usercmdButton_t fireModeSwap; // Offset: 0x8

        // jump button
        usercmdButton_t jump; // Offset: 0x10

    }; // Size: 0x18

    // what is my current fire mode
    idDemonPlayer_Mancubus::eMancubusFireMode currentFireMode; // Offset: 0x36FC8

    // Main fire whether the next shot is from the right hand
    bool rightHandShot; // Offset: 0x36FCC

    // how many rocket pairs left to fire in this volley
    int currentBurstCount; // Offset: 0x36FD0

    // when the next shot comes within the volley
    idTypesafeTime < long long , gameTimeUnique_t , 999960 > nextBurstTime; // Offset: 0x36FD8

    // time when the burst began
    idTypesafeTime < long long , gameTimeUnique_t , 999960 > burstStartTime; // Offset: 0x36FE0

    // burst count
    int burstCount; // Offset: 0x36FE8

    // mortar when are we able to swap fire modes again?
    idTypesafeTime < long long , gameTimeUnique_t , 999960 > nextFireModeSwapTime; // Offset: 0x36FF0

    // next time flamethrower can fire
    idTypesafeTime < long long , gameTimeUnique_t , 999960 > nextFlamethrowerTime; // Offset: 0x36FF8

    idTypesafeTime < long long , gameTimeUnique_t , 999960 > lastMortarUseFailTime; // Offset: 0x37000

    // flamethrower are they holding down alt fire and primary fire
    bool wantsToShootFlames; // Offset: 0x37008

    // have they readied flames for the first time
    bool hasReadiedFlames; // Offset: 0x37009

    // have they let go of the flame button since firing
    bool hasReleasedAfterFlame; // Offset: 0x3700A

    // heat how much heat have we accumulated
    float currentHeatAmount; // Offset: 0x3700C

    // how much heat we had in the last frame
    float previousHeatAmount; // Offset: 0x37010

    // when was the last time we drained heat
    idTypesafeTime < long long , gameTimeUnique_t , 999960 > lastHeatDrainTime; // Offset: 0x37018

    // last time heat was depleted
    idTypesafeTime < long long , gameTimeUnique_t , 999960 > lastHeatDepletedTime; // Offset: 0x37020

    // whether the demon is overheated locally for us
    bool isOverheatedLocally; // Offset: 0x37028

    // whether the server thinks the demon is overheated
    bool isOverheatedOnServer; // Offset: 0x37029

    // disallow firing until the manc has touched the ground after a double jump
    bool disableFireFromDoubleJump; // Offset: 0x3702A

    // interpolater to smoothly blend the hands in/out of overheat state
    idInterpolate < float , idTypesafeTime < long long , gameTimeUnique_t , 999960 > > overheatedHandsBlend; // Offset: 0x37030

    // Traversal integer distance moved on ground, used for podium stat
    int totalDistanceMovedOnGround; // Offset: 0x37060

    // last primary fire blend anim index we used
    int lastHandAnimIndex; // Offset: 0x37064

    bool isFalling; // Offset: 0x37068

    bool useJumpCooldown; // Offset: 0x37069

    float distanceFallen; // Offset: 0x3706C

    // Used to determine how close the ground is
    idHavokQueryId fallTrace; // Offset: 0x37070

    // Game time when the smoke FX from the mortar will end
    idTypesafeTime < long long , gameTimeUnique_t , 999960 > mortarSmokeEndTime; // Offset: 0x37078

    // Time it takes for the mortar smoke to dissipate
    idTypesafeTime < int , millisecondUnique_t , 1000 > mortarSmokeTimeToFinish; // Offset: 0x37080

    // play slam / restrict movement at this height ( minimum of 5 meters )
    float fallSlamHeight; // Offset: 0x37084

    // how long to restrict player movement after slam
    idTypesafeTime < int , millisecondUnique_t , 1000 > slamMovementRestrictTime; // Offset: 0x37088

    // max height for double jump
    float maxDoubleJumpHeight; // Offset: 0x3708C

    // cooldown when mancubus lands after jump
    idTypesafeTime < int , millisecondUnique_t , 1000 > jumpCooldownAfterLanding; // Offset: 0x37090

    // how long slam landings last
    idTypesafeTime < int , millisecondUnique_t , 1000 > slamLandingDuration; // Offset: 0x37094

    // how much to scale movement during slam landings
    float slamLandingMovementScale; // Offset: 0x37098

    // how long double jump boost lasts
    idTypesafeTime < int , millisecondUnique_t , 1000 > doubleJumpBoostDuration; // Offset: 0x3709C

    // local sound to play when heat is full
    idSoundEvent* heatFullSound; // Offset: 0x370A0

    // local sound to play when heat is empty
    idSoundEvent* heatEmptySound; // Offset: 0x370A8

    // looping overheat warning sound
    idSoundEvent* overheatWarningSound; // Offset: 0x370B0

    // looping overheated alarm sound
    idSoundEvent* overheatAlarmSound; // Offset: 0x370B8

    // overheat warning stop sound event (WWise)
    idSoundEvent* overheatWarningStopSound; // Offset: 0x370C0

    // overheated alarm stop sound event (WWise)
    idSoundEvent* overheatAlarmStopSound; // Offset: 0x370C8

    // sound to make when mancubus slams to the ground
    idSoundEvent* landingSound; // Offset: 0x370D0

    // sound to make when mancubus slams to the ground
    idSoundEvent* slamLandingSound; // Offset: 0x370D8

    // screen shake decl to play upon landing
    idDeclAdvancedViewShake* landingViewShake; // Offset: 0x370E0

    // screen shake decl to play upon a slam landing
    idDeclAdvancedViewShake* slamLandingViewShake; // Offset: 0x370E8

    // mancubus-specific data
    idDemonPlayer_Mancubus::mancubusData_t mancubusData; // Offset: 0x370F0

    // flamethrower specific data
    idDemonPlayer_Mancubus::flamethrowerData_t flamethrowerData; // Offset: 0x37170

    // mortar attack data
    idDemonPlayer_Mancubus::mortarData_t mortarData; // Offset: 0x373F8

    // last time the flamethrower was started
    idTypesafeTime < long long , gameTimeUnique_t , 999960 > flamethrowerStartTime; // Offset: 0x37490

    // Revenant input bindings
    idDemonPlayer_Mancubus::MancubusInput inputBindings; // Offset: 0x37498

}; // Size: 0x374B0
